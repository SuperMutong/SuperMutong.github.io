---
layout:     post
title:      小知识点总结
subtitle:   
date:       2017-12-27
author:     Mutong
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - 基础
    - 随记
---

# 零碎小知识

随手记录一些零碎小知识

### 	1. performSelector  和 直接调方法的区别
&emsp;&emsp;performSelector:withObject: 是在 iOS 中的一种方法调用方法, 他可以向一个对象传递任何消息, 而不需要在编译的时候声明这些方法, 也算是 runtime 的一种应用方法, 这个方法会阻塞线程
&emsp;&emsp;直接调用方法在编译器是会自动校验的, 如果方法不存在, 会有警告, 但是使用 performSelector 的话一定是在运行时才能发现, 如果此方法不存在, 就会 crash. 所以如果使用 performSelector 的话, 有个最佳伴侣  
`-(BOOL)respondsToSelector:(SEL)aSelector; ` 
来在运行时判断对象是否响应此方法
[详细介绍](https://www.jianshu.com/p/672c0d4f435a)

### 2. Runtime 如何实现 weak 属性
&emsp;&emsp;Runtime 对注册的类, 会进行布局, 对于 `weak`对象会放入一个 hash 表中. 值为弱引用 , ,用 `weak`指向的对象内存内存地址为 key, 当次对象的引用计数为 0 的时候会 `dealloc`, 在以对象的内存地址为 key 在 `weak`表中搜索, 找到以 key 为键的 weak 对象, 从而设置为 nil

### 3. 使用 Runtime Associate 方法关联的对象, 需要在主对象 dealloc 的时候释放么?
&emsp;&emsp;不需要, 因为被关联的对象在生命周期内要比对象本身释放的晚, 他们会在 NSObject -dealloc 调用的 object_dispose()方法中释放
&emsp;&emsp;对象的内存销毁时间表, 分为四个步骤
1. 调用 -release 引用计数变为0
	1. 对象正在被销毁, 生命周期即将结束
	2. 不能再有新的 _weak 弱引用, 否则将指向 nil
	3. 调用 [self dealloc]
2. 父类调用 -dealloc
	1. 继承关系中最直接继承的父类再调用 -dealloc
	2. 继承关系中每一层的父类, 都在调用 -dealloc
	3. NSObject 调用 -dealloc
		1. 只做一件事情: 调用 Objective-C runtime 中 object_dispose() 方法
4. 调用  object_dispose()
	1. 为 C++ 的实例变量们(iVars) 调用 destructors
	2. 为 ARC 状态下的实例变量们 (iVars) 调用 -release
	3. 解除所有使用 runtime Associate 方法关联的对象
	4. 解除所有 _weak 引用
	5. 调用 free()  

### 4. 能否向编译后得到的类中添加实例变量? 能否向运行时创建的类中添加实例变量? 为什么?		
&emsp;&emsp;不能向编译后得到的类中增加实例变量, 能向运行时创建的类中添加实例变量

1. 因为编译后的类已经注册在 runtime 中, 类结构体(objc_class)中的 objc_ivar_list 实例变量的链表和 instance_size 实例变量的内存大小已经确定, 同时 runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用, 所以不能向存在的类中添加实例变量
2. 运行时创建的类是可以增加实例变量, 调用 class_addIvar 函数, 但是得在调用 objc_allocateClassPair 之后, objc_registerClassPair 之前, 原因同上

### 5. [self class] 和 [super class] 的区别
当 super 关键字接收到消息时, 编译器会创建一个 `objc_super` 结构体

```objc
struct objc_super { id receiver; Class class;};
```

这个结构体指明了消息应该被传递给特定超类的定义. 但是 `receiver` 仍然是 `self` 本身,因为当我们想通过 `[super class]` 获取超类时, 编译器只是将指向 `self` 的 `id` 指针和 `class` 的 SEL 传递给`objc_msgSendSuper` 函数, 因为只有在 NSObject 类才能找到 class 方法, 然后 class方法调用 `object_getClass()`,接着调用 `objc_msgSend(objc_super->receiver,@selector(class))`,传入的第一个参数是指向 `self` 的 `id` 指针, 与调用`[self class]` 相同, 所以我们得到的永远都是 self 的类型

### 6. 如何获取某个方法选择器对应的 IMP
&emsp;&emsp;NSObject 类中有一个实例方法: methodForSelector, 你可以用它来获取某个方法选择器对应的 IMP, 比如
```objc
void (*setter)(id,SEL,BOOL);
int i;
setter = (void (*)(id,SEL,BOOL))[target methodForSelector:@selector(setFilled:)];
for(i=0;i<100-;i++){
setter(targetList[i],@selector(setFilled:),YES);
}
```

### 7. KVO 内部实现原理
1. KVO 是基于 runtime 机制实现的
2. 当某个类的对象第一次被观察时, 系统就会在运行期动态地创建该类的一个派生类以及派生类的元类, 在这个派生类中重写基类中任何被观察属性的 setter 方法, 这个时候你使用`object_getClass()` 获取当前类的类型的时候, 其实已经改成了`NSKVONotifying_XX`了 
3. 派生类在被重写的 setter 方法中实现真正的通知机制
[详细解释](https://www.jianshu.com/p/e59bb8f59302)

### 8. Runtime 常见函数
1. `class_copyIvarList`: 获取某各类内部的所有成员变量
2. `class_copyMethodList`:获取某个类内部的所有方法
3. `class_getInstanceMethod`:获取某个具体的实例方法(对象方法, 减号开头)
4. `class_getClassMethod`:获得某个具体的类方法(加号)
5. `method_exchangeImplementations`:交换两个方法的实现

###9.  objc 在向一个对象发送消息时, 发生了什么?
1. 先检测这个 `selector` 是不是可以被忽略的, 
2. 检测这个 `target` 是不是为 `nil` 对象,  Objc 的特性是允许对一个 nil 对象执行任何一个方法不会 crash,
3. 开始查找这个方法的 `IMP`指针, 先从` cache` 中找,如果找到直接执行
4. 如果 `cache` 中找不大, 就是 当前对象的 `methodList` 中查找, 再去 父类的 `MethodList` 中查找, 一直找到 NSObject 为止
5. 如果还是找不到, 开始进入了动态方法解析了

### 10. 动态方法解析的流程
1. 先调用 `resolveInstanceMethod`:(动态方法解析) 方法, 指定是否动态添加方法, 如果返回 `NO`, 则进入下一步, 若返回 `YES`, 则通过 `class_addMethod` 函数动态的添加方法, 消息得到处理, 此流程完毕
2. `forwardingTargetForSelector`:(重定向)方法, 这是 runtime 给我们的第二次机会, 用于指定那个对象响应这个` selector `, 如果返回 nil, 则进入到下一步, 若返回某个对象, 则会调用该对象的方法
3. 通过 `methodSignatureForSelector`: 指定方法签名, 如果返回 nil, 不做处理,  若返回方法签名, 则会进入到下一步
4. 当 methodSignatureForSelector: 方法返回方法签名后, 就会调用 forwardInvocation: (转发)方法, 我们可以通过 anInvocation 对象做很多处理, 比如修改实现方法, 修改响应对象等
6. 到了这一步, 消息没有的饿到响应, 程序就会 crash

### 11. 什么时候会报 unrecognized selector 错误, 有什么机制可以避免走到这一步
&emsp;&emsp;当方法找不到的时候回报这个错误, 如果避免看 第 10 个问题

### 12. 给类添加一个属性后, 类的结构体那些元素发生了变化
`instance_size`: 实例的内存大小
`objc_ivar_list *ivar` 成员变量列表

### 13. copy&mutableCopy



看看这个图片
![](https://upload-images.jianshu.io/upload_images/295346-bd95431918be69b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

主要还是这两篇博客
* [http://www.cnblogs.com/yswdarren/p/3611924.html](http://www.cnblogs.com/yswdarren/p/3611924.html)
* [https://www.jianshu.com/p/e6a7cdcc705d](https://www.jianshu.com/p/e6a7cdcc705d)


### iOS性能优化

主要还是表格的优化, 表格创建方法的不合适容易掉帧, 严重的话会卡顿, 感觉追求极致的话可以完全用YYkit那一套开源的空间搭建UI

可以从提前计算cell动态高度,  圆角的优化, 离屏渲染, 少用xib, 透明度, 渐变之间慎用, 

罗列几个可以参考的博客

* [https://www.jianshu.com/p/b8346c1a4145](https://www.jianshu.com/p/b8346c1a4145)
* [https://www.jianshu.com/p/f3e18bab841e](https://www.jianshu.com/p/f3e18bab841e)
* [http://wereadteam.github.io/2016/05/03/WeRead-Performance/](http://wereadteam.github.io/2016/05/03/WeRead-Performance/)
* [http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/)
* [https://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&mid=402351449&idx=1&sn=3ef1c82a123da76a1e899ab70bb5e9f7&scene=1&srcid=0118mcBfdWRqJ8w20WOqmbvh#rd](https://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&mid=402351449&idx=1&sn=3ef1c82a123da76a1e899ab70bb5e9f7&scene=1&srcid=0118mcBfdWRqJ8w20WOqmbvh#rd)

### 发布自己的开源库

[教程](https://www.jianshu.com/p/3a365f273439)


### 优化启动时间

[教程](https://juejin.im/entry/59e6fb7051882521b45fc1bc)
