---
layout:     post
title:      RunTime 学习笔记
subtitle:   RunTime
date:       2017-12-27
author:     Mutong
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - 基础
    - RunTime
---


###  RunTime 学习笔记
		1.简介
			因为 Objc 是一门动态语言, 所以他总是想办法把一些决定工作从编译连接推迟到运行时, 这就需要一个运行时系统 (runtime system) 来执行编译后的代码, 这就是 Objective-C Runtime 系统存在的意义, 他是整个 Objc 运行框架的一块基石
			为了动态系统的高效, 所以 Runtime  基本是用 C 和汇编写的,
		2.[receiver message]
		编译器会把他转换成 
			`bjc_msgSend(receiver, selector)` 
			或者
		    `objc_msgSend(receiver, seletor,arg1,arg2)`
		如果消息的接受者能够找到对应的 selector, 那么就相当于直接执行了接受者这个对象的特定方法, 否则, 消息要么被转发, 或者临时向接受者动态添加这个 selector 对应的实现内容, 要么干脆玩完奔溃
		现在可以看出 [receiver message] 真的不是一个简简单单的方法调用, 因为这只是在编译阶段确定了要向接受者发送 message 这条消息, 而 receive 将要如果响应这条消息, 那就要看运行时发生的情况来决定了

		3.与 Runtime 交互
			Objc 从三种不同的层级上与 Runtime 系统进行交互, 分别是通过 OC 源代码, 通过 Foundation 框架的 NSObject 类定义的方法, 通过对 runtime 函数的直接调用
			1. Objective-c 源代码
				大部分情况下你就只管写 OC 代码, Runtime 系统自动在底层处理
			2. NSObject 的方法, 这个没理解, 有时间在看下 yulingtianxia 的博客
			3. Runtime 的函数
				Runtime 系统是一个由一系列函数和数据结构组成, 具有公共接口的动态共享库许多函数允许你用纯 C 代码来重复实现 Objc 中同样的功能, 你在写 Objc 代码时一般不会直接用到这些函数, 除非写一些 Objc 与其他语言的桥接或者底层的 debug 工作
#### Runtime 基础数据结构
	1. 前面提到了 objc_msgSend:方法, 他的真身其实是下面这个
		id objc_msgSend(id self, SEL op, ...)
		参数解读
			1. id 他是一个指向类实例的指针
				typedef struct objc_object *id
			    struct objc_object {
							private:
							    isa_t isa;
							public:
					    // ISA() assumes this is NOT a tagged pointer object
					    Class ISA();
					    // getIsa() allows this to be a tagged pointer object
					    Class getIsa();
					    ... 此处省略其他方法声明
					}

				objc_object 结构体包含一个 isa 指针, 类型为 isa_t 联合体, 根据 isa 就可以找到对象所属的类, 但是 isa 指针不总是指向实例类对象所属的类, 不能依靠他来确定类型, 而是应该用 class 方法来确认实例对象的类, 因为 KVO 的实现机理就是讲被观察对象的 isa 指针指向一个中间类而不是真是的类, 这是一种叫做 isa-swizzling 的技术
			2. SEL 他是 selector 在 Objc 中的表达类型,  在 Swift 中是 Selector 类. selector 是方法选择器, 可以理解为区分方法的 ID, 而这个 ID 的数据结构是 SEL.   不同类中相同名字的方法对应的方法选择器是相同的, 即使方法名字相同而变量类型不同也会导致他们具有相同的方法选择器, 因为 selector 只记了 method 的 name, 没有参数
			3. ... 代表参数, 是变参, 也就是方法携带的参数, 可以没有, 可以有多个
			4. Class  一个指向 objc_class 结构体的指针
				struct objc_class:objc_object{
					Class isa  isa指向其所属的元类
					Class super_class  超类
					const char *name  类名
					long version   类的版本信息
					long info   类的详情
					struct objc_ivar_list *ivars  类的成员变量列表
					struct objc_method_list **methodLists 实例方法列表 即 -func
					struct objc_cache *cache  被调用的方法存到 cache 中, 方便下次查找
					struct objc_protocol_list *protocols  该类的协议列表

					class_data_bits_t bits }
					这里解释下元类, 先从类对象开始
					类对象: 它是由编译器创建的, 即在编译时所谓的类 比如 NSString, NSArray, 就是指类对象, 
					objc_class 继承自 objc_object , 为了处理类和对象的关系, runtime 库创建了一个叫做元类 (meta class) 的东西, 类对象所属类型就叫做元类, 它用来表述类对象本身所具备的元数据, 每个类仅有一个类对象, 而每个类对象仅有一个与之相关的元类, 类方法存储在元类中 类方法 +func
					元类就是类对象的类, 类对象是元类的实例
					我们以前调用 "+" 开头的类方法实际是在调用元类的对象方法
					由于每个类有且只有一个, 所以每个类对象都是其对应元类的单例
					我们接触到的大部分 OC 对象都继承自 NSObject, 这里直接以 NSObject 为例
						1. 每个实例对象的类都是类对象, 每个类对象的类都是元类对象, 每个元类对象的类都是根元类
						2. 类对象的父类最终继承自根类对象 NSObject, NSObject 的父类为 nil
						3. 元类对象 (包括根元类) 的父类最终继承自根类对象 NSobject
						看下图
						
![](https://ws4.sinaimg.cn/large/006tNc79ly1fmh4c8l9koj30e00epaak.jpg)
![enter image description here](http://blogofzuoyebuluo.qiniudn.com/image_note64271_1.png)

			小知识: 元 (meta) 是什么	
			meta 在英语中并不是单字, 通常会和后面的词链接起来, 用来描述后面的词, 表示 "关于...的...", 举个例子, meta-data 就是关于数据的数据, 即这个数据大小, 类型等用来描述数据的数据信息, 在比如 meta-language 就是关于语言的语言, meta-class 就是关于类的类
			
			1. cache_t 
```
		struct cache_t {
			struct bucket_t *_buckets;
			mask_t _mask;
			mask_t _occupied;
			..... 省略其他方法
			}
```

			_buckets 存储 IMP, _mask 和 _occupied对应 vtable
			cache 为方法调用的性能进行优化, 通俗的讲, 每当实例对象接收到一个消息时, 它不会直接在 isa 指向的类的方法列表中遍历查询找能够响应的方法, 因为这样的效率太低了, 而是优先在 cache 中查找, Runtime 系统会把调用的方法存储到 cache 中 (理论上讲一个方法如果被调用, 那么他有可能今后还会被调用), 下次查找的时候效率更高
			bucket_t 中存储了指针与 IMP 的键值对
			2.  objc_class 包含了 class_data_bits_t , class_data_bits_t 存储了 class_rw_t 的指针, 而 class_rw_t 结构体又包含 class_ro_t 的指针
			3.  class_ro_t 它里面的 method_list_t , ivar_list_t property_list_t 结构体都继承自 entsize_list_tt<Element, List, FlagMAsk>
				entsize_list_tt 实现了 non-fragile 特性的数组结构体, 假如苹果在新版本的 SDK 中向 NSObject 类增加了一些内容, NSObject 的战局的内存区域会扩大, 开发者以前编译出的二进制中的子类就会与新的 NSObject 内存有重叠部分, 于是在编译期会给 instanceStart 和 instanceSize 赋值, 确定好编译时每个类所占内存区域起始偏移量和大小, 这样只需要将子类与基类的这两个变量做对比即可知道子类是否与基类有重叠, 如果有, 也可知道子类需要挪多少偏移量
				class_ro_t 存储的大多是类在编译时就已经确定的信息
			4. class_rw_t
					class_rw_t 提供了运行时对类拓展的能力, 但是如上文所说, class_ro_t 存储的大多是类在编译时已经确定的信息, 二者都存有类的方法, 属性(成员变量), 协议等信息, 不过存储他们的列表实现方式不同
					class_rw_t 中使用的 method_Array_t , property_array_t, protocol_Array_t 都继承自 list_array_tt<Element, List>, 他可以不断扩张, 因为他可以存储 list 指针
					 class_rw_t 的内容是可以在运行时被动态修改的, 可以说运行时对类的拓展大都存储在这里
					
		5. Category
					 Category 为现有的类提供拓展性, 它是 category_t 结构体的指针
					 category_t 存储了类别中可以拓展的实例方法. 类方法 . 协议. 实例属性.和类属性
					 我这里有一篇文章是学习 Category 的笔记 
[链接](https://supermutong.github.io/2017/12/17/Category%E7%AC%94%E8%AE%B0/)				
	 						 
		6. Method 代表类中的某个方法的类型
				Method 的类型是 method_t
				typedef struct method_t *Method
				struct method_t {
						SEL name; 
						const char *types;
						 IMP imp;
				}
				方法名类型为 SEL, 前面提到过相同名字的方法即使在不同类中定义, 他们的方法选择器也相同.
				方法类型 types 是个 char 指针, 其实存储着方法的参数类型和返回值类型.
				imp 指向了方法的实现, 本质上是一个函数指针
		7. Ivar 代表类中实例变量的类型
			类型是inva_t 
		8. objc_property_t 
			@property 标记了类中的属性, 他是一个指向 objc_property 结构体的指针
			可以通过 class_copyPropertyList 和 protocol_copyPropertyList 方法来获取类和协议中的属性, 返回类型为指向指针的指针, 因为属性列表是个数组, 每个元素内容都是一个 objc_property_t 指针, 而这两个函数返回的值都是指向这个数组的指针
		9. IMP  在 objc.h 中的定义是
			typedef void (*IMP)(void /* id, SEK, ... */);
			他就是一个函数指针, 是由编译器生成的, 当你发起一个 Objc 消息后, 最终他会执行的那段代码, 就是由这个函数指针指定的, 而 IMP 这个函数指针就指向了这个方法的实现

#### 	消息
		Objc 中发送消息是用中括号 [] 把接受者和消息括起来, 而直到运行时才会把消息和方法实现绑定
		objc_msgSend 函数
		1. 消息发送步骤
			1. 检测这个 Selector 是不是要忽略的, MAC 开发中有个函数是要忽略的
			2. 检测这个 target 是不是 nil 对象, Objc 的特性是允许对一个 nil 对象执行任何一个方法不会 crash , 因为被忽略掉了
			3. 如果上面两个都过了, 那就开始查找这个类的 IMP, 先从 cache 里面找, 如果找到就跳到对应的函数去执行
			4. 如果 cache 找不到就找一下方法分发表
			5. 如果方法分发表中找不到就到超类的分发表去找, 一直找, 直到找到 NSObject 类为止
			6. 如果还找不到就要开始动态方法解析了
		2. 动态解析方法
			 Runtime 系统在 Cache 和方法分发表中(包括超类) 找不到要执行的方法的时候, Runtime 会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给程序员一次动态添加方法实现的机会, 我们需要用 class_addMethod 函数完成向特定类添加特定方法实现的操作
			1. 理解 [self class]  object_getClass(self) object_getClass([self class])
				1. 当 self 为实例对象时,  [self class] 与 object_getClass(self) 等价, 因为前者会调用后者, object_getClass([self class]) 得到元类
				2. 当 self 为类对象时, [self class] 返回值为自身, 还是 self, object_getClass(self) 与 object_getClass([self class]) 等价, 返回元类
				
		3. 消息转发  
				1. 重定向
				在消息转发机制执行前, Runtime 系统会在给我们一次偷梁换柱的机会, 即通过重载 - (id)forwardingTargetForSelector:(SEL)aSelector 方法替换消息的接受者为其他对象
```
		-(id)forwardingTargetForSelector:(SEL)aSelector{
			if (aSelector == @selector(mysteriousMthod:)){
				return alternateObject;
			}
			return [super forwardingTargetForSelector:aSelector];
			}
```
				毕竟消息转发要耗费更多时间, 抓住这次机会将消息重定向给别人是一个不错的机会.  如果此方法返回 nil 或 self , 则会进入消息转发机制, 否则将向返回的对象重新发送消息
				如果想替换类方法的接受者, 需要覆盖 + (id)forwardingTargetForSelector:(SEL)aSelector 方法, 并返回类对象
				一会咱们用 runtime 替换掉系统的 forwardingTargetForSelector 的方法, 来减少 crash
				
			2. 转发 当动态方法解析不作处理返回 NO 时, 消息转发机制会被触发, 在这时 forwardInvocation: 方法会被执行, 我们可以重写这个方法来定义我们的转发逻辑
					记住我们在重写的同时也要重写 methodSignatureForSelector:方法, 否则会抛异常
					
			3. 转发和多继承
					一个对象把消息转发出去, 就好似它把另一个对象的方法借过来或是"继承"过来一样
					消息转发弥补了 Objc 不支持多继承的性质, 也避免了因为多继承导致单个类变得臃肿负责, 它将问题分解的很细, 只针对想要借鉴的方法才转发
					尽管转发很像继承, 但是 NSObject 类不会将两者混淆,, 像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑集成体系, 不会考虑转发链
					 
		5.  消息转发的大致流程
![](https://ws3.sinaimg.cn/large/006tNc79ly1fmvlh7ubysj30m80h6dg5.jpg)
		
			1. 进入 resolveInstanceMethod: 方法(动态方法解析), 指定是否动态添加方法. 若返回 NO, 则进入下一步, 若返回 YES , 则通过 class_addMethod 函数动态地添加方法, 消息得到处理, 此流程完毕
			2. resolveInstanceMethod: 方法返回 NO 时, 就会进入 forwardingTargetForSelector: 方法(重定向), 这是 Runtime 给我们的第二次机会, 用于指定那个对象响应这个 selector, 如果返回 nil, 进入下一步, 返回某个对象, 则会调用该对象的方法
			3. 若 forwaringTargetForSelector: 返回的是 nil, 则我们首先要通过 methodSignatureForSelector: 来指定方法签名, 返回 nil, 表示不处理, 若返回方法签名, 则会进入下一步
			4. 当 methodSignatureForSelector: 方法返回方法签名后, 就会调用 forwardInvocation: 方法(转发), 我们可以通过 anInvocation 对象做很多处理, 比如修改实现方法, 修改响应对象等
			5. 如果到最后, 消息还是没有得到相应, 程序就会 crash, 
				
		6. 消息发送的流程
![](https://ws2.sinaimg.cn/large/006tKfTcly1fmv6hdb9ruj30t71asgmm.jpg)
			
	7.Method SEL Imp 三者的关系
	
			1. Method 
				struct objc_method{
					SEL method_name  方法名
					char *method_types  方法类型
					IMP method_imp}    方法实现
					Method 就是表示能够独立完成一个功能的一段代码, 比如声明一个方法
					-(void)logName{
						 NSLog(@"name")
					 }
					SEL 和 IMP 其实是 Method 的属性
			2. SEL
					typedef struct objc_selector *SEL
					selector 是 SEL 的一个实例, selector 是方法选择器, 可以理解为区分方法的 ID , selector 只记了 method 的 name, 没有参数, 所以没法区分不同的 method, 
			3. IMP  本质是函数指针, 指向实现方法的内存地址的指针
			4. 总结:
				在 Runtime 中, Method 通过 selector 和 IMP, 两个属性, 实现了快速查询方法及实现, 相对提高了性能, 又保持了灵活性	
				
				一道面试题
					
			 如何通过 selector 找到对应的 IMP 地址
				1. 概述
					类对象中有类方法和实例方法的列表, 列表中记录着方法的名词, 参数和实现, 而 selector 本质就是方法名称, runtime 通过这个方法名称就可以在列表中找到该方法对应的实现
				2. 具体实现
					在寻找 IMP 的地址时, runtime 提供了两种方法
					1. IMP class_getMethodImplementation(Class cls, SEL name)  官方文档说这个方法可能更快一些
						1. 类方法和实例方法实际上都是通过调用 class_getMethodImplementation()来寻找 IMP 地址的, 不同之处在于传入的第一个参数不同
							1. 类方法 (假设有一个类 A)
								class_getMethodImplementation(objc_getMetaClass("A",@selector(methodName)))
							2. 实例方法
								class_getMethodImplementation([A class],@selector(methodName))
					2. IMP method_getImplementation(Method m)
					     1. 这个方法传入的参数只有 method, 区分类方法和实例方法在于封装method 的函数
						     1. 类方法
							     Method class_getClassMethod(Class cls, SEL name)
							 2. 实例方法
								 Method class_getInstanceMethod(Class cls, SEL name)
						最后调用 IMP method_getImplementation(Method m) 获取 IMP 地址  

####  Method Swizzling
		当我们无法触碰到某各类的源代码, 但是又想更改这个类的某个方法的实现时, 就要用到 Method Swizzling 了, 下面举一例子, 这个例子是为了防止系统找不到调用方法 crash 的问题, 比如你添加一个 UIButton, 给 btn 添加 selector, 但是没有实现对应的 selector, 这个时候你点击 btn, 就会 crash. 为了防止类似的 crash ,我们用 Method Swizzling 重写 forwardingTargetForSelector 消息重定向, 下面开始贴代码
		首先, 我们先实现一个转发对象 FakeForwardTargetObjct 
		
```ruby
		fakeIMP(id sender, SEL sel,...){
						    return nil;	
			}
		@implementation FakeForwardTargetObjct
			-(instancetype)initWithSelector:(SEL)aSelector{
				self = [super init];
				if (self) {
					if (class_addMethod([self class], aSelector, (IMP)fakeIMP, NULL)) 
						{
						     NSLog(@"add Fake Selector:[instance %@]",NSStringFromSelector(aSelector));
						}
				}
				return self;
		@end
```	
	
	接着实现转发逻辑
	
```ruby
		implementation NSObject (safeSwizzle)
		+ (void)load{
		    static dispatch_once_t onceToken;
		    dispatch_once(&onceToken, ^{
			Class aClass = [self class];
			SEL originalSelector = @selector(forwardingTargetForSelector:);
			SEL swizzleSelector = @selector(safeForwardingTargetForSelector:);

			Method originalMethod = class_getInstanceMethod(aClass, originalSelector);
			Method swizzleMethod = class_getInstanceMethod(aClass, swizzleSelector);

			BOOL didAddMethod = class_addMethod(aClass, originalSelector, method_getImplementation(swizzleMethod), method_getTypeEncoding(swizzleMethod));

			if (didAddMethod) {
			    class_replaceMethod(aClass, swizzleSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
			}
			else{
			    method_exchangeImplementations(originalMethod, swizzleMethod);
			}

		    });
		}

		- (id)safeForwardingTargetForSelector:(SEL)aSelector{

		    NSMethodSignature *signature = [self methodSignatureForSelector:aSelector];
		    if ([self respondsToSelector:aSelector] || signature) {
			return [self safeForwardingTargetForSelector:aSelector];
		    }
		    FakeForwardTargetObjct *tmp = [[FakeForwardTargetObjct alloc]initWithSelector:aSelector];
		    return tmp;
		}
		end
```


参考博客
 
http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/

http://www.jianshu.com/p/efeb33712445#

http://www.jianshu.com/p/d63028fc978f

http://blog.csdn.net/njafei/article/details/71172428

https://njafei.github.io/2017/05/03/Method-SEL-IMP/

http://www.code4app.com/blog-822715-1562.html

https://www.jianshu.com/p/ab966e8a82e2


