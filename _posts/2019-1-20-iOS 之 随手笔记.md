---
layout:     post
title:      小知识点总结
subtitle:   
date:       2019-1-20
author:     Mutong
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - 基础
    - 随记
---

# 零碎小知识

随手记录一些有趣小知识

### iOS各版本直接的不同

[简书](https://www.jianshu.com/p/576fcfe8340e)

### HTTP2

[知乎](https://zhuanlan.zhihu.com/p/26559480)
优点:
* 多路复用, 同一个域名下的请求都是通过一个TCP连接并发完成
* 服务器推送, 服务器可以在发送页面HTML时主动推送其他资源, 而不用等到浏览器解析到对应位置
* 头部压缩, 头部相同的数据,不再通过每次请求和响应发送

### TCP协议总结

讲的挺详细的, tcp流控制和拥塞控制的发生和预防都讲了下, 就是博客中的图片资源找不到了, 得显示源码才能摘到图片资源
[博客](http://lastdays.cn/2016/02/04/TCP/)

### Method Swizzling 

[博客](http://www.tanhao.me/code/160723.html/)

楼主详细的介绍了类和实例的`Method Swizzling`方法, 也讲解了如何把已经exchange的方法在此exchange回去

### 转换内存管理权

* __bridge: 只做了类型转换, 不修改内存管理权
* __bridge_retained(即CFBridgingRetain) 转换类型, 同时将内存管理权从ARC中移除, 后面需要使用CFRelease来释放对象
* __bridge_trasnsfer (即CFBridgingRelease) 将Core Foundation 的对象转换为OC的对象, 同时将内存管理权交给ARC

### 算法

[排序算法总结](https://michaelyou.github.io/2015/03/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/)

[快速排序](http://www.cnblogs.com/pugang/archive/2012/07/02/2573075.html)

### 死锁产生的原因

[知乎](https://zhuanlan.zhihu.com/p/25677118)
[死锁队列优先级翻转](https://blog.csdn.net/goodwillyang/article/details/45603873)

互斥锁可以分为递归锁和非递归锁, 二者唯一的区别是, 同一个线程可以多次获取同一个递归锁,不会产生死锁. 而如果一个线程多次获取同一个非递归锁,则会产生死锁

### pod install/update

[CSDN](https://blog.csdn.net/ShorewB/article/details/52207569)

### 数据结构之链表和线性表

[CSDN](https://blog.csdn.net/index20001/article/details/74075743)
[CSDN](http://www.cnblogs.com/QG-whz/p/4118103.html)

### Charles 实现原理
[简书](https://www.jianshu.com/p/4682aecf162d)

### static const extern 

[简书](https://www.jianshu.com/p/8fc75d0831fe)
[简书](https://www.jianshu.com/p/4bc8a57257ae)

### NSCache 和 NSDictionary

NSCache 是苹果提供的一套缓存机制, `NSDictionary` 有的功能他也有, 而且他由一些比`NSDictionary`好的地方

1. NSCache 是线程安全的, NSMutableDictionary 线程不安全
2. 当内存不足的时候NSCache回自动释放内存
3. NSCache可以指定缓存的限额, 当缓存超出限额会先移除最先创建的
4. NSCache的key, 可以不用支持copying协议

[简书](https://www.jianshu.com/p/47400383dfe0)
[简书](https://www.jianshu.com/p/239226822bc6)

### 	1. performSelector  和 直接调方法的区别
performSelector:withObject: 是在 iOS 中的一种方法调用方法, 他可以向一个对象传递任何消息, 而不需要在编译的时候声明这些方法, 也算是 runtime 的一种应用方法, 这个方法会阻塞线程

直接调用方法在编译器是会自动校验的, 如果方法不存在, 会有警告, 但是使用 performSelector 的话一定是在运行时才能发现, 如果此方法不存在, 就会 crash. 所以如果使用 performSelector 的话, 有个最佳伴侣  
`-(BOOL)respondsToSelector:(SEL)aSelector; ` 
来在运行时判断对象是否响应此方法

[详细介绍](https://www.jianshu.com/p/672c0d4f435a)

### 2. Runtime 如何实现 weak 属性
&emsp;&emsp;~~Runtime 对注册的类, 会进行布局, 对于 `weak`对象会放入一个 hash 表中. 值为弱引用 , ,用 `weak`指向的对象内存内存地址为 key, 当此对象的引用计数为 0 的时候会 `dealloc`, 在以对象的内存地址为 key 在 `weak`表中搜索, 找到以 key 为键的 weak 对象, 从而设置为 nil~~

4.22更新

`runtime`维护了一个weak表, 用来存储指向某个对象的所有weak指针, weak表其实是一个hash表,, key是所指对象的地址, value是weak指针的`地址`(这个地址的值是所指对象指针的地址)数组

比如我有一个对象A, 里面有很多weak声明的属性 对象B, 对象C, 对象D, 那我这个hash表的结构就是 key是A的地址, value是一个数组, 里面是B指针的地址, C指针的地址, D指针的地址

当前对象释放如何处理weak表: 首先根据对象的地址获取所有的weak指针的数组, 然后遍历这个数组,根据其中指针的地址找到对应的指针, 置为nil, 然后从weak表中删除该记录

如果当前对象还在, 但是weak指向的对象释放的时候如何处理?

系统会遍历全部的weak表, 然后找到要释放的对象

[简书](https://www.jianshu.com/p/13c4fb1cedea)


### 3. 使用 Runtime Associate 方法关联的对象, 需要在主对象 dealloc 的时候释放么?
不需要, 因为被关联的对象在生命周期内要比对象本身释放的晚, 他们会在 NSObject -dealloc 调用的 object_dispose()方法中释放

对象的内存销毁时间表, 分为四个步骤
1. 调用 -release 引用计数变为0
	1. 对象正在被销毁, 生命周期即将结束
	2. 不能再有新的 _weak 弱引用, 否则将指向 nil
	3. 调用 [self dealloc]
2. 父类调用 -dealloc
	1. 继承关系中最直接继承的父类再调用 -dealloc
	2. 继承关系中每一层的父类, 都在调用 -dealloc
	3. NSObject 调用 -dealloc
		1. 只做一件事情: 调用 Objective-C runtime 中 object_dispose() 方法
4. 调用  object_dispose()
	1. 为 C++ 的实例变量们(iVars) 调用 destructors
	2. 为 ARC 状态下的实例变量们 (iVars) 调用 -release
	3. 解除所有使用 runtime Associate 方法关联的对象
	4. 解除所有 _weak 引用
	5. 调用 free()  

### 4. 能否向编译后得到的类中添加实例变量? 能否向运行时创建的类中添加实例变量? 为什么?		
&emsp;&emsp;不能向编译后得到的类中增加实例变量, 能向运行时创建的类中添加实例变量

1. 因为编译后的类已经注册在 runtime 中, 类结构体`(objc_class)`中的 `objc_ivar_list` 实例变量的链表和 `instance_size` 实例变量的内存大小已经确定, 同时 runtime 会调用 `class_setIvarLayout` 或 `class_setWeakIvarLayout` 来处理 strong weak 引用, 所以不能向存在的类中添加实例变量
2. 运行时创建的类是可以增加实例变量, 调用 `class_addIvar` 函数, 但是得在调用 `objc_allocateClassPair` 之后, `objc_registerClassPair` 之前, 原因同上

### 5. [self class] 和 [super class] 的区别
当 super 关键字接收到消息时, 编译器会创建一个 `objc_super` 结构体

```objc
struct objc_super { id receiver; Class class;};
```

这个结构体指明了消息应该被传递给特定超类的定义. 但是 `receiver` 仍然是 `self` 本身,因为当我们想通过 `[super class]` 获取超类时, 编译器只是将指向 `self` 的 `id` 指针和 `class` 的 SEL 传递给`objc_msgSendSuper` 函数, 因为只有在 NSObject 类才能找到 class 方法, 然后 class方法调用 `object_getClass()`,接着调用 `objc_msgSend(objc_super->receiver,@selector(class))`,传入的第一个参数是指向 `self` 的 `id` 指针, 与调用`[self class]` 相同, 所以我们得到的永远都是 self 的类型

### 6. 如何获取某个方法选择器对应的 IMP
&emsp;&emsp;NSObject 类中有一个实例方法: methodForSelector, 你可以用它来获取某个方法选择器对应的 IMP, 比如
```objc
void (*setter)(id,SEL,BOOL);
int i;
setter = (void (*)(id,SEL,BOOL))[target methodForSelector:@selector(setFilled:)];
for(i=0;i<100-;i++){
setter(targetList[i],@selector(setFilled:),YES);
}
```

### 7. KVO 内部实现原理
1. KVO 是基于 runtime 机制实现的
2. 当某个类的对象第一次被观察时, 系统就会在运行期动态地创建该类的一个派生类以及派生类的元类, 在这个派生类中重写基类中任何被观察属性的 setter 方法, 这个时候你使用`object_getClass()` 获取当前类的类型的时候, 其实已经改成了`NSKVONotifying_XX`了 
3. 派生类在被重写的 setter 方法中实现真正的通知机制, 里面调用`[self willChangeValueForKey:@""];`和`[self didChangeValueForKey:@""];`

[详细解释](https://www.jianshu.com/p/e59bb8f59302)

### 8. Runtime 常见函数
1. `class_copyIvarList`: 获取某各类内部的所有成员变量
2. `class_copyMethodList`:获取某个类内部的所有方法
3. `class_getInstanceMethod`:获取某个具体的实例方法(对象方法, 减号开头)
4. `class_getClassMethod`:获得某个具体的类方法(加号)
5. `method_exchangeImplementations`:交换两个方法的实现

### 9.  objc 在向一个对象发送消息时, 发生了什么?
1. 先检测这个 `selector` 是不是可以被忽略的, 
2. 检测这个 `target` 是不是为 `nil` 对象,  Objc 的特性是允许对一个 nil 对象执行任何一个方法不会 crash,
3. 开始查找这个方法的 `IMP`指针, 先从` cache` 中找,如果找到直接执行
4. 如果 `cache` 中找不大, 就是 当前对象的 `methodList` 中查找, 再去 父类的 `MethodList` 中查找, 一直找到 NSObject 为止
5. 如果还是找不到, 开始进入了动态方法解析了

### 10. 动态方法解析的流程
1. 先调用 `resolveInstanceMethod`:(动态方法解析) 方法, 指定是否动态添加方法, 如果返回 `NO`, 则进入下一步, 若返回 `YES`, 则通过 `class_addMethod` 函数动态的添加方法, 消息得到处理, 此流程完毕
2. `forwardingTargetForSelector`:(重定向)方法, 这是 runtime 给我们的第二次机会, 用于指定那个对象响应这个` selector `, 如果返回 nil, 则进入到下一步, 若返回某个对象, 则会调用该对象的方法
3. 通过 `methodSignatureForSelector`: 指定方法签名, 如果返回 nil, 不做处理,  若返回方法签名, 则会进入到下一步
4. 当 `methodSignatureForSelector:` 方法返回方法签名后, 就会调用 `forwardInvocation:` (转发)方法, 我们可以通过 anInvocation 对象做很多处理, 比如修改实现方法, 修改响应对象等
6. 到了这一步, 消息没有的饿到响应, 程序就会 crash

### 11. 什么时候会报 unrecognized selector 错误, 有什么机制可以避免走到这一步
&emsp;&emsp;当方法找不到的时候回报这个错误, 如果避免看 第 10 个问题

### 12. 给类添加一个属性后, 类的结构体那些元素发生了变化
`instance_size`: 实例的内存大小

`objc_ivar_list *ivar` 成员变量列表

### 13. copy&mutableCopy



看看这个图片
![](https://upload-images.jianshu.io/upload_images/295346-bd95431918be69b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

主要还是这两篇博客
* [http://www.cnblogs.com/yswdarren/p/3611924.html](http://www.cnblogs.com/yswdarren/p/3611924.html)
* [https://www.jianshu.com/p/e6a7cdcc705d](https://www.jianshu.com/p/e6a7cdcc705d)


### iOS性能优化

主要还是表格的优化, 表格创建方法的不合适容易掉帧, 严重的话会卡顿, 感觉追求极致的话可以完全用YYkit那一套开源的空间搭建UI

可以从提前计算cell动态高度,  圆角的优化, 离屏渲染, 少用xib, 透明度, 渐变之间慎用, 

罗列几个可以参考的博客

* [https://www.jianshu.com/p/b8346c1a4145](https://www.jianshu.com/p/b8346c1a4145)
* [https://www.jianshu.com/p/f3e18bab841e](https://www.jianshu.com/p/f3e18bab841e)
* [http://wereadteam.github.io/2016/05/03/WeRead-Performance/](http://wereadteam.github.io/2016/05/03/WeRead-Performance/)
* [http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/)
* [https://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&mid=402351449&idx=1&sn=3ef1c82a123da76a1e899ab70bb5e9f7&scene=1&srcid=0118mcBfdWRqJ8w20WOqmbvh#rd](https://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&mid=402351449&idx=1&sn=3ef1c82a123da76a1e899ab70bb5e9f7&scene=1&srcid=0118mcBfdWRqJ8w20WOqmbvh#rd)

### 发布自己的开源库

[教程](https://www.jianshu.com/p/3a365f273439)


### 优化启动时间

[教程](https://juejin.im/entry/59e6fb7051882521b45fc1bc)

### 属性关键词

[博客](https://www.jianshu.com/p/8b3cf2187255)

### 优雅的拉伸图片

[博客](https://www.jianshu.com/p/a577023677c1?utm_source=tuicool&utm_medium=referral)

### LLDB 调试的基本用法

[博客](http://blog.csdn.net/Ji_Jingjing/article/details/50697822)
[调试](https://joakimliu.github.io/2015/05/22/Some-Debug-Method-in-iOS/)
[输出model全部属性](http://blog.csdn.net/biggercoffee/article/details/50429408)

### iOS触摸事件传递

[博客](https://www.jianshu.com/p/8dca02b4687e)

### AFNetworking 详细解析

[简书](https://www.jianshu.com/p/856f0e26279d)

### TCP三次握手/四次挥手

[知乎](https://www.zhihu.com/question/67772889)

最萌哒哒的解释. 233333333

假设2个人要相互确认对方已经收到自己的消息需要几步;
面试官:   嘿准备好了吗？;
我:  准备好了; 
面试官: 那我开始问了;

三次握手保证了通信双方有通信的基础


you---->server

面试官: hi 我问完了
我: 我也答完了;
我: 那就先这样, 我先撤?;
面试官: 好的，我也撤了;

四次挥手保证了通讯双方可以安全的回收TCP通信的系统资源

### +(void)load 和 +(void)initialize

[文章](https://www.jianshu.com/p/24fbd2e9bb28)

### 优雅的圆角

用CAShapeLayer+UIBezierPath结合

CAShapeLayer动画渲染直接提交到手机GPU当中, 效率极高, 能大大优化内存使用情况

[文章](http://www.imlifengfeng.com/blog/?p=593)

### Instrments 使用指导

[文章](https://www.jianshu.com/p/92cd90e65d4c)

### get post的区别

post 比 get 安全一点点, 这一点点就是get可以在浏览器中请求, 但是post不行

post 有 body

[知乎](https://www.zhihu.com/question/31640769?rf=37401322)

### Binary search tree

Binary search tree:二叉搜索树。 
主要由四个方法：（用C语言实现或者Python）
 
1.search：时间复杂度为O(h)，h为树的高度

2.traversal：时间复杂度为O(n)，n为树的总结点数。

3.insert：时间复杂度为O(h)，h为树的高度。

4.delete：最坏情况下，时间复杂度为O(h)+指针的移动开销。

可以看到，二叉搜索树的dictionary operation的时间复杂度与树的高度h相关。所以需要尽可能的降低树的高度，由此引出平衡二叉树Balanced binary tree。它要求左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这样就可以将搜索树的高度尽量减小。常用算法有红黑树、AVL、Treap、伸展树等。

### 经典面试题

[面试](https://github.com/ChenYilong/iOSInterviewQuestions/tree/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88)

### Block和Delegate的区别

[知乎](https://www.zhihu.com/question/29023547)

### iOS本地数据存储

[简书](https://www.jianshu.com/p/a620b8ae7ab7)

数据库那一节他用的是系统的数据库, 其实可以借用 [FMDB](https://github.com/ccgus/fmdb) 更简洁的实现存储功能呢, keyChain那一节如果借用[sskeychain](https://github.com/samsoffes/sskeychain)更方便了

### iOS如何正确的实现行间距

在用`attributeds`设置行高的时候需要把系统的自带边距减去, 如下图重叠部分
```oc
paragraphStyle.lineSpacing = 10 - (label.font.lineHeight - label.font.pointSize);
```

![](https://user-gold-cdn.xitu.io/2018/3/29/1626fabdbf367b64?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

[文章详情](https://juejin.im/post/5abc54edf265da23826e0dc9)