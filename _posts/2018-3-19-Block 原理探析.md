---
layout:     post
title:      Block 原理探析
subtitle:   
date:       2018-3-19
author:     Mutong
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - 基础
    - Block
---


## Block 原理探析

### 概述

`Block`是苹果在iOS4开始引入的对的对C语言的扩展, 用来实现匿名函数的特性, Block是一种特殊的数据类型, 其可以正常定义变量,作为参数, 作为返回值,特殊的`Block`还可以保存一段代码, 在需要的时候调用. 

苹果推出 `Block` 是因为其有很多优点, 如下

* `Block`的代码是内联的, 效率高于函数调用
* `Block`对于外部变量默认是只读属性
* `Block`被`OC`看成是对象处理

### 基本概念

`Block`: 带有`自动变量`的`匿名函数`

`匿名函数`: 没有函数名的函数, 一对`{}`包裹的内容是匿名函数的作用域

`自动变量`:栈上声明的一个变量不是静态变量或全局变量, 是不可以在这个栈内声明的匿名函数中使用, 但是在`Block`中却可以

### Block语法

Block 表达式语法:
```oc
 ^ 返回值类型(参数列表){表达式}
```

返回值和参数列表都可以忽略, 最简模式语法:
```
^{表达式}
```

例如:
```c
^ int (int count) {
    return count + 1;
}
```

### Block类型变量

声明Block类型变量语法
```
返回值类型(^变量名)(参数列表) = Block表达式
```

例如

```oc
    int (^blk)(int) = ^(int count){
        return count+1;
    };
```

当Block类型变量作为函数的参数是, 写作:

```oc
- (void)func:(int(^)(int))blk{}
```

可以借助 typeDef 简写
```oc
typedef int (^blk)(int);
- (void)func:(blk)b{}
```

### 截取变量值

Block表达式可截获所使用的变量的值

但是, 只是保存变量的`瞬间值`, 即使在Block外在此修改变量的值, 也不会对Block内截取的变量值产生影响, 比如:
```oc
int i = 10;
void (^blk)(void) = ^{
    //i++ //这里直接会报错

    NSLog(@"In block, i = %d", i);
};

i = 20;//Block外修改变量i，也不影响Block内的自动变量;

blk();//i修改为20后才执行，打印: In block, i = 10;

NSLog(@"i = %d", i);//打印：i = 20;
```

这个时候你只能获取当初Block获取到的值, 而且不能修改这个值, 如果你在Block中修改这个值Xcode会报错, 如果想修改这个值, 需要用到了 `__block`修饰符
```oc
__block int i = 10;
void (^blk)(void) = ^{
    i++

    NSLog(@"In block, i = %d", i);
};

i = 20;

blk();//输出21

NSLog(@"i = %d", i);//打印：i = 21;
```

#### 变量值为一个对象

当自动变量为一个类的对象, 且没有使用__block修饰是, 虽然不可以在Block内对该变量进行重新赋值, 但是可以改变该对象的属性.

如果这个对象时继承自`NSObject`的`Person`类, 里面有一个属性`name`, 实例化`p` 在Block中可以修改`p`的`name`属性, 但是不能从新初始化`p`

```oc
Person *p = [[Person alloc]init];
void (^blk)(void) = ^{    
    
    //p = [[Person alloc]init]; //这里Xcode直接报错 提示用 __block修饰符

    NSLog(@"start %@",p.userName);//输出xiaoming

};
p.userName = @"xiaoming";
blk();
```

下面咱们会解释下__block 做了点啥和Block的实现原理

### Block实现原理
在 `main.h`文件中添加一个Block
```oc
        int valA = 1;
        __block int valB = 11;
        void (^block)(void) = ^{
//            valA = 2;
            valB = 22;
            NSLog(@"%d, %d", valA, valB);
        };
        block();
```

使用clang命令`clang -rewrite-objc`查看源码

```c
struct __Block_byref_valB_0 {
  void *__isa;
__Block_byref_valB_0 *__forwarding;
 int __flags;
 int __size;
 int valB;
};
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc; //描述Block大小, 版本等信息
  int valA;
  __Block_byref_valB_0 *valB; // by ref
  //构造函数
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _valA, __Block_byref_valB_0 *_valB, int flags=0) : valA(_valA), valB(_valB->__forwarding) {
    impl.isa = &_NSConcreteStackBlock;//在函数栈上声明, 则为_NSConcreteStackBlock
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_valB_0 *valB = __cself->valB; // bound by ref
  int valA = __cself->valA; // bound by copy
            (valB->__forwarding->valB) = 22;
            NSLog((NSString *)&__NSConstantStringImpl__var_folders_6p_1hbzwy3900vd5kkrph4hz29w0000gn_T_main_9fdbf1_mi_0, valA, (valB->__forwarding->valB));
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->valB, (void*)src->valB, 8/*BLOCK_FIELD_IS_BYREF*/);}
static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->valB, 8/*BLOCK_FIELD_IS_BYREF*/);}
static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
int main(int argc, char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        int valA = 1;
        __attribute__((__blocks__(byref))) __Block_byref_valB_0 valB = {(void*)0,(__Block_byref_valB_0 *)&valB, 0, sizeof(__Block_byref_valB_0), 11};
        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, valA, (__Block_byref_valB_0 *)&valB, 570425344));
        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);
        return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("AppDelegate"), sel_registerName("class"))));
    }
}
```

`__main_block_impl_0`里面有个`__block_impl`结构体, 声明如下
```c
struct __block_impl {
  void *isa;//指明对象的Class
  int Flags;
  int Reserved;
  void *FuncPtr;
};
```

和OC代码一起比较看

偷来的图

![](http://aevit.qiniudn.com/71dc6fd24fd4df90c1a91b2bb7d3b5b01483953745.jpeg)

block 被转化成一个`__main_block_impl_0` 结构体对象, 这个结构体对象时`main()`函数栈上的Block结构体, 传入的第一个参数是一个`__main_block_func_0`类型的变量, 这个变量将会由结构体里的`FuncPtr`成员接收, 可以看到这是一个函数指针

可以看出, Block也是Object-C中的对象. Block有三类

* _NSConcreteStackBlock: 在栈上创建的Block对象
* _NSConcreteMallocBlock: 在堆上创建的Block对象
* _NSConcreteGlobalBlock: 全局数据区的Block对象


### 参考博客
* [https://www.jianshu.com/p/d28a5633b963](https://www.jianshu.com/p/d28a5633b963)
* [http://aevit.xyz/2017/01/09/iOS-__block/](http://aevit.xyz/2017/01/09/iOS-__block/)