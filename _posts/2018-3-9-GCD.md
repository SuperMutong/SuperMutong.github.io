---
layout:     post
title:      GCD 总结
subtitle:   
date:       2018-3-9
author:     Mutong
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - 基础
    - GCD
---

## GCD 总结

最终还是觉得得写一篇关于GCD的笔记, 看一遍记不住. 顺道在温习下Swift

笔记是基于 Swift4 写的

## 基本概念

先从最简单的`进程`,`线程`说起

### 进程&线程

#### 进程
一个正在运行的程序可以看做一个进程, 比如一个正在运行的App, 进程拥有独立运行所需要的全部资源

每个进程之间是独立的, 每个进程均运行在其专用且受保护的内存空间呢

#### 线程
程序中独立运行的代码段

一个进程是由一或多个线程组成. 进程只负责资源的调度和分配, 线程才是程序真正的执行单元, 负责代码的执行

一个程序至少包含一个进程, 一个进程至少包含一个线程, 一个进程中的所有线程共享当前进程所拥有的的资源


### 什么是GCD

`CGD` 全称 `Grand Central Dispatch` , 汉化版:宏伟的中枢调度器. 

确切的说是一套低层级的 C API,因为是纯`C`语言实现的,很高效, 提供了非常多的强大函数. 可以对 MacOS iOS, WatchOS 中的多核硬件的并发代码执行提供
系统全面的改进, 使系统和应用程序运行的更快, 更高效, 并且响应更快, 能够充分调用CPU多核高效率工作, 以均衡的方法将他们与可用的系统资源进行分配



### 内部如何实现

iOS 和 OS X 和核心是XNU内核, GCD是基于XNU内核实现的, GCD的API全部在`libDispatch`库中(又碰到这个东西了, 在RunLoop里面碰到过), `libDispatch`为并发代码在iOS和OS X 的多核硬件上执行提供了支持.

GCD的底层实现主要由 `Dispatch Queue` 和 `Dispatch Source`

*  Dispatch Queue: 管理block (操作)
*  Diapatch Source: 处理事件(MACH端口发送, MACH 端口接受, 检测与进程相关的事件)

### 优点

* 易用: GCD提供了一个易于使用的并发模型而不仅仅只有锁和线程, 以帮助我们避开并发陷阱, 而且因为基于`block`, 它能极为简单的在不同代码作用域之间传递上下文
* 灵活: GCD 具有在常见模式上(比如单例,锁)用更高效性能的方法优化代码, 而且GCD能提供更多的控制权以及大量的底层函数
* 性能: GCD 能自动根据系统负载来增减线程数量, 这样减少了上下文切换以及增加了计算效率

### GCD 相关概念

#### Dispatch Objects

GCD 是纯C语言的,但它被组建成面向对象的风格. GCD对象被称为`dispatch object`. 所有的`dispatch objects` 都是OC对象, 就如其他OC对象一样会有引用计数

#### Serial&Concurrent

* 串行任务就是每次只有一个任务被执行
* 并发任务就是在同一时间可以有多个任务被执行

#### Synchronous & Asynchronous

* 同步: 完成了它预订的任务才返回, 在任务执行时会阻塞当前线程,使用 `.sync`将任务加入队列. 
    - 将同步任务加入串行队列, 会顺序执行, 但是如果在任务没结束时调用其他同步任务会死锁. 
    - 将同步任务加到并行队列, 会顺序执行, 但是没意义
* 异步: 不用等待任务的完成而执行下面的任务, 异步函数不会堵塞当前线程, 使用`.async`加入到队列中. 
    - 将异步任务加入串行队列,会顺序执行, 并且不会出现死锁问题. 
    - 将异步任务加入并行队列, 会并行执行多个任务, 常用方式

#### Context Switch

上下文切换, 一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程. 这个过程在便器多任务时很普遍, 但会带来一些额外的开销

#### Dispatch Queues

dispatch queues 是一个强大的执行多任务的工具. Dispatch queue 是一个对象, 它可以接受任务, 并将任务以先进先出(FIFO)的顺序来执行. Dispatch queue 可以并发的或者串行的执行任一一个代码块, 并且并发任务会基于系统负载来合适的并发进行

串行队列同一时间只执行单一任务, Dispatch queues 内部使用的是线程, GCD 管理这些线程, 并且使用Dispatch queues 的时候, 我们不需要自己创建线程

Dispatch queues 相对于和线程直接通信的代码的优势: Dispatch queues 使用起来特别方便, 执行任务更加效率


### GCD 队列

* 并发队列

并发队列虽然是能同时执行多任务, 但是这些任务仍然是按照先到先执行(FIFO)的顺序来执行的. 并发队列会基于系统负载来合适的选择并发执行这些任务. 无法真正做到大量队列的并行执行, 而且如果对于并行队列中的全局队列而言, 也是存在优先级关系的, 执行的时候也会遵循其优先级

我们可以用`DispatchQueue`,并指定队列类型`.concurrent`, 来自己创建一个并发队列
```swift
        let concurrentQueue = DispatchQueue(label: "queuename", attributes:.concurrent)
```

* 串行队列

串行队列将任务以先进先出(FIFO)的顺序来执行, 一个串行队列在同一时间里只会执行一个任务, 而且每次都只会从队列的头部把任务取出执行, 正因为如此,串行队列经常用来访问某些特定资源的同步处理来替代锁的操作

我们可以在程序中创建任意数量的队列, 不过我们应该尽量避免创建大量的穿行队列. 虽然GCD通过创建所谓的线程池来大致匹配CPU内核数量, 但是线程的创建并不是无代价的. 每个线程都需要占用内存和内核资源

```swift
//默认什么也不写就是串行队列
    let serialQueue = DispatchQueue(label: "queuenam")
```

这里又一张总结的表格 

| 队列  | 同步执行 | 异步执行 |
|------|---------------|-------------|
| 串行队列|当前线程, 一个一个执行|其他线程, 一个一个执行|
|并行队列|当前线程, 一个一个执行|开几个线程, 一起执行|



* 主线程队列

特殊的串行队列, 队列中的任务一次只能执行一个. 他能保证所有的任务都是在主线程执行, 而主线程是唯一可以用于更新UI的线程

```swift
    DispatchQueue.main.async{
        主线程
    }
```

* 全局队列 global queue

特殊的并发队列, 依旧保持了并行队列的特点, 但是 `global queue` 对于 `dispatch_suspend`(暂停), `dispatch_resume`(恢复), `dispatch_set_context`(切换上下文) 这几个函数无响应

看下`dispatch queue`队列的优先级

swift版的`GCD`苹果引入了 `QoS`(Quality of Service) 的概念, 这几个名称和 OC 的不一样了

```swift
public enum QoSClass {

        case background  //后台

        case utility    //低 DISPATCH_QUEUE_PRIORITY_LOW

        case `default`  //=DISPATCH_QUEUE_PRIORITY_DEFAULT

        case userInitiated //= DISPATCH_QUEUE_PRIORITY_HIGH

        case userInteractive //与用户交互的任务, 这些任务通常跟UI级别的刷新相关, 比如动画

        case unspecified  //未指明
}
```

可以在全局队列中多点需要时间的操作

```swift
      let glQueue = DispatchQueue.global(qos: .default)
        glQueue.async {
            sleep(10)
            print("sleep2")
        }
```

* 自定义队列

自己也开创建串行队列也可以创建并行队列

```swift
let concurrentQueue = DispatchQueue(label: "queuename", attributes:.concurrent)
//默认是串行
let serialQueue = DispatchQueue(label: "queuenam")
```

### GCD常见用法和应用场景

#### async

不会堵塞当前线程

最常见的应用场景, 异步线程请求图片, 数据返回以后主线程刷新UI
```swift
DispatchQueue.xxx.async {

}
```


```swift
let glQueue = DispatchQueue.global(qos: .default)
glQueue.async {
    //一些下载操作
    self.PrintLog("start sleep")
    sleep(2)
    DispatchQueue.main.async {
        //主线程刷新UI
        self.PrintLog("UI 刷新")
    }
}
```

如果是自己写的异步请求数据在数据下拉以后也需要调用`.main`刷新数据, 但是大家都是用过`AFNetworking`, 使用`AFNetworking`以后直接刷新UI就可以了, 不用再加`main.async{}`这行代码, 这是因为`AFNetworking`做了优化, 帮我们省略了这一步, 详情可以看下`AFNetworking`的源码

#### sync

创建同步任务, 这个任务会堵塞当前线程

```swift
DispatchQueue.XXX.sync {

}
```


聊完`sync`和`async`, 来两道经典的面试题

* 实例一:

看看下面这个会输出啥

```swift
print("start")
DispatchQueue.main.sync {
    print("hello world")
}
print("end")
```

结果: 打印了`start`,然后crash, 都不给你卡死的机会, 错误提示
```swift
EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)
```

当初用它来面试的时候, 还是卡死, 现在苹果已经优化到crash的地步了

分析:

同步线程会阻塞当前线程, 然后等到把`Block`中的任务放到指定的队列中执行, 只有等到`Block`中的任务完成后太会让当前任务进行下去

打印完`start`以后, `sync`会立即堵塞当前的线程, 然后把`block`中的代码放到`main`队列中, 可是`main`中的任务会被取出来放到主线程中执行, 但是主线程已经被阻塞了, 所以`block`中的任务就不能完成, 他不完成, `sync`就会一直堵塞线程, 两者相互等待, 想成了死锁


* 实例二

实例二是实例一的加强版
```swift
print("start")
DispatchQueue.main.async {
    print("sync 之前")
    DispatchQueue.main.sync {
        print("sync中")
    }
    print("sync后")
}
print("end")
```

结果:

输出`start`, `end` 和`sync 之前`, 这三句话, 然后在此crash, 错误依旧是
```swift
Thread 2: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)
```


分析:

主线程也是一种串行队列

先打印了`start`, 然后`main`的`async`开始异步执行, `async`并不会堵塞当前线程, 所以继续往下输出, 直接打印`end`. 接着打印`sync 之前`, 然后就`crash`了, 原因和实例一是一样的

为什么会堵塞当前线程,是因为底层有个信号量的东西, 有个前辈的博客写的很不错, 从源码底层开始解释的, 强烈推荐研究下 

![源码](https://www.jianshu.com/p/5e6300cb3fc5)

![https://www.jianshu.com/p/d56064507fb8](https://www.jianshu.com/p/d56064507fb8)

#### after

```swift
 DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) {
            self.PrintLog("两秒后")
    }
```

简单的延迟执行, 延迟执行方法很多, 这只是其中的一种


#### once

在 swift3 中被废弃了, OC中`dispatch_once`经常用来实现单例, 贴段`OC`代码

```oc
#import "SingletonVC.h"
// 创建静态对象 防止外部访问
static SingletonVC * _singletonVC;
@implementation SingletonVC
+ (instancetype)allocWithZone:(struct _NSZone *)zone{
    
    static dispatch_once_t onceToken;
    // 一次函数
    dispatch_once(&onceToken, ^{
        if (_singletonVC == nil) {
            _singletonVC = [super allocWithZone:zone];
        }
    });
    
    return _singletonVC;
}
+ (instancetype)share{
    
    return  [[self alloc] init];
}
```

#### 单例

因为在Swfit中无法使用`dispatch_once`, 所以要实现单例就要用另外一种方法了

#### group

队列组可以将很多队列添加到一个组里, 这样做的好处是, 当这个组里所有的同步任务执行完了, 队列组会收到一个通知.

先看一段简单版的`group`
```
 let group = DispatchGroup()

        queueBook.async(group: group) {
            printf("任务一")
        }

        queueVideo.async(group: group) {
            printf("任务二")
        }
        group.notify(queue: DispatchQueue.main) {
            //打印任务一和任务二以后才会收到通知
            print("完成");
        }
```

简单版的`group`里面的任务只能是串行任务, 如果`group`的任务里面有并行任务, 上面的用法就不能得到正确的结果了.得借用`enter`和`leave`了, 如下 

一道经典的面试题, 先执行任务A和任务B去下载图片, 下载完成后通知任务C加工图片

```swift
let group = DispatchGroup()
let queueBook = DispatchQueue(label: "book")
group.enter()
queueBook.async(group: group) {
    // 任务A
    DispatchQueue.main.async {
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now()+1, execute: {
            sleep(2)
            print("sleep2")
            group.leave()
        })
    }
}
group.enter()
let queueVideo = DispatchQueue(label: "video")
queueVideo.async(group: group) {
    // 任务B
    DispatchQueue.main.async {
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now()+1, execute: {
            sleep(2)
            print("sleep3")
            group.leave()
        })
    }
}
group.notify(queue: DispatchQueue.main) {
    // 任务C
    print("完成");
}
```


#### barrier

barrier 的作用科技用一个词概括--承上启下, 它保证此前的任务都先于自己执行, 此后的任务也迟于自己执行, 看下面的例子, 任务3 4 永远都是在 任务 1 2 以后执行

```swift
let queue = DispatchQueue(label: "queue", attributes:.concurrent)

    queue.async {
        print("sleep1")
    }
    queue.async {
        print("sleep2")
    }
    let write = DispatchWorkItem(flags: .barrier) {
        print("barrier")
    }
    queue.async(execute: write)

    queue.async {
        print("sleep3")
    }
    queue.async {
        print("sleep4")
    }
```

在这里遇到了一个问题, 如果任务是异步任务, 比如去请求网络数据, 这个时候不会等待数据返回就会往下执行

它和`group`类似, 也是异步任务间的一种同步方式, 可以在比如文件的读写操作时使用, 保证读写操作的精确性

还有一点需要注意:`async.barrier`和`sync.barrier`只在自己创建的并发队列上有效, 在全局`gloabl`并发队列, 串行队列, 效果跟`sync`和`async`效果一样


#### apply

`apply` 并行的运行机制, 效率一般快于`for`循环的串行机制, 因为它是并行机制, 导致执行顺序无法控制, 如果这可以用来拉取网络数据后提前算出各个控件的大小, 防止绘制时计算, 提高表单滑动流畅性

如果用`for`循环耗时较多, 并且每个表单的数据没有依赖关系, 可以用`apply`试试

but

swift 给这个用法改名了, 改成了`concurrentPerform`, 效果的apply一样

```swift
DispatchQueue.concurrentPerform(iterations: 10) { (index) in
            self.PrintLog(index)
}
```


#### 互斥锁

给需要同步的代码块加一个互斥锁, 就可以保证每次只有一个线程访问此代码块

```swift
objc_sync_enter(self)
//需要执行的任务
objc_sync_exit(self)
```
























* ![https://www.jianshu.com/p/d56064507fb8](https://www.jianshu.com/p/d56064507fb8)
* ![https://www.jianshu.com/p/266bec7c4dd2](https://www.jianshu.com/p/266bec7c4dd2)
* ![https://www.jianshu.com/p/0b0d9b1f1f19](https://www.jianshu.com/p/0b0d9b1f1f19)
* ![https://www.jianshu.com/p/ff444d664e51](https://www.jianshu.com/p/ff444d664e51)
* ![https://www.jianshu.com/p/fc78dab5736f](https://www.jianshu.com/p/fc78dab5736f)